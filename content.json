{"meta":{"title":"Hoff's blog","subtitle":null,"description":null,"author":"Hoff","url":"http://yoursite.com/younghf.github.io"},"pages":[{"title":"about","date":"2017-11-30T03:04:47.000Z","updated":"2017-11-30T07:12:40.967Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/younghf.github.io/about/index.html","excerpt":"","text":"征服自己的一切弱点，正是一个人伟大的起始！ — Hoff·Young 折腾了许久，终于搭好了自己的博客。希望自己能坚持写下去吧，记录学习中的一点一滴，直到有一天，量变引起质变！"}],"posts":[{"title":"ES6学习","slug":"ES6学习","date":"2017-12-07T16:46:08.000Z","updated":"2017-12-08T04:58:46.040Z","comments":true,"path":"2017/12/08/ES6学习/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/08/ES6学习/","excerpt":"","text":"let 与 var 作用域只局限于当前代码块 123456&#123; var str = &quot;张三&quot; let str1 = &quot;李四&quot;&#125;console.log(str) // 张三console.log(str) // 会报错not defined 声明的变量作用域不会被提升 1234567&#123; console.log(str) // undefined var str = &quot;张三&quot; console.log(str1) // 会报错not defined let str1 = &quot;李四&quot;&#125; 在相同的作用域下不能声明相同的变量 123456&#123; let str1 = &quot;张三&quot;; let str1 = &quot;李四&quot;; console.log(str1) // 报错&#125; for 循环提现let的作用域 1234567var oLi = document.getElementsByTagName(&apos;li&apos;);for (var i = 0;i &lt; oLi.length;i++)&#123; oLi[i].onclick = function ()&#123; alert(i) &#125;&#125;// 这里alert的结果均为li标签的总个数 1234567891011// 通常我们会使用闭包解决这个问题var oLi = document.getElementsByTagName(&apos;li&apos;);for (var i = 0;i &lt; oLi.length;i++)&#123; (function (i)&#123; oLi[i].onclick = function ()&#123; alert(i) &#125; &#125;)(i)&#125;// 这里alert的结果为 0 到 oLi.length-1； 1234567891011121314// ES6的let就不会存在以上的问题var oLi = document.getElementsByTagName(&apos;li&apos;);for (let i = 0;i &lt; oLi.length;i++)&#123; oLi[i].onclick = function ()&#123; alert(i) &#125;&#125;// 这里alert的结果为 0 到 oLi.length-1；for (let i = 0;i &lt; 5;i++)&#123; let i = 20; console.log(i) // 输出了5次 20 ；&#125; const 作用域只局限于当前代码块 123456&#123; const str = &quot;张三&quot; console.log(str) // 张三&#125;console.log(str) // 会报错not defined 声明的变量作用域不会被提升 1234&#123; console.log(str1) // 会报错not defined const str1 = &quot;李四&quot;&#125; 不能重复声明 123456&#123; const str1 = &quot;张三&quot;; const str1 = &quot;李四&quot;; console.log(str1) // 报错&#125; 声明的变量必须赋值 123456&#123; const str; str = &quot;张三&quot;; console.log(str) // 会报错 &#125; const声明的变量一般不能修改，引用类型除外 1234567891011121314&#123; const str = “李四”; str = &quot;张三&quot;; console.log(str) // 会报错，const声明的变量一般不能修改，引用类型除外，如下&#125;&#123; const obj = &#123;name:&apos;张三&apos;&#125;; console.log(obj) // &#123;name:&apos;张三&apos;&#125; obj.name = &quot;李四&quot;; console.log(obj) // &#123;name:&apos;李四&apos;&#125;&#125; 解构赋值 基本用法 123456789 let name = &quot;张三&quot;,age = 18,sex = &quot;男&quot;; let [name,age,sex] = [&quot;张三&quot;,&quot;18&quot;,&quot;男&quot;] console.log(name) // 张三 console.log(age) // 18 console.log(sex) // 男 ``` 2. 对象解构赋值 let { name , age , sex} = {name : “张三” , age : 55, sex: “男”}; console.log(name) // 张三 console.log(age) // 55 console.log(sex) // 男 1 let { name , age , sex} = {name : “张三” , age : 55, friends : [“李四” , “王五”] ,sex: “男”}; console.log(name) // 张三 console.log(age) // 55 console.log(sex) // undefined 1 let {name : str} = {name:”张三”} console.log(name) // 为空，不能打印出信息 console.log(str) // 张三 13. 数组的结构赋值 let [name , age , sex] = [“张三”, 22 , “女”] let [arr,[arr1 , arr2 , [arr3 , arr4]]] = [0 , [1 , 2 , [3 , 4]]] let [arr5] = [] console.log(arr5) // undefined 1 let [a,,c] = [1,2,3] console.log(c) // 3 1 let [a , , , c] = [1,2,3] console.log(c) // undefined 14. 基本类型的结构赋值 let [a, b ,c ,d]= ‘我是小明’; console.log(a) console.log(b) console.log(c) console.log(d) 1 let [a, b ,c ,d , e]= 12306; console.log(a) // Uncaught TypeError: 12306 is not iterable 123456789101112 &gt;### 新增的数据类型 - Set**特点*** 类似数组，没有重复的元素（唯一的） * 开发中用于去重 * key和value都是相等的1. 创建一个集合 ![set.jpg](set.jpg) let set = new Set([‘张三’,’李四’,’王五’,’王五’]); console.log(set) // 会去重 123 ![set1.jpg](set1.jpg) 2. 一个属性 - size let set = new Set([‘张三’,’李四’,’王五’,’王五’]); console.log(set.size) // 3 1233. 四个方法 * add set.add(“刘德华”).add(“小明”) 1* delete set.delete(“刘德华”) 1* has set.has(“张三”) // true set.has(“刘德华”) // false 1* clear console.log(set.clear()) // undefined 没有返回值 14. keys values console.log(set.keys()) console.log(set.values()) 123456789 ![key_value.jpg](key_value.jpg) &gt;### Map**特点*** 类似于对象，本质上是键值对的集合* “键”不局限于字符串，各种类型的值（包括对象）都可以当做键* 对象：“字符串 - 值”，Map：“值 - 值”，是一种更加完善的Hash结构的实现 let obj = {},obj1 = {a:1},obj2 = {b:2};11. 创建一个Map let obj1 = {a:1},obj2 = {b:2}; const map = new Map([ [&apos;name&apos;,&apos;张三&apos;], [&apos;age&apos;,18], [&apos;sex&apos;,&apos;男&apos;], [obj1,&apos;天气很好&apos;], [obj2,&apos;适合敲代码&apos;], [[1,2],&apos;牛逼啊&apos;] ]) console.log(map) 12345678910111213 ![map.jpg](map.jpg) 2. 常用属性 - size console.log(map.size) ![map1.jpg](map1.jpg)3. 方法 ![map2.jpg](map2.jpg)4. set get delete has clear keys(获取键) values(获取值) entries(获取键值) map.set(&apos;friends&apos;,[&apos;赵六&apos;,&apos;李七&apos;]).set([&apos;dog&apos;,&apos;小花&apos;]); map.get(&apos;obj1&apos;) map.delete(&apos;obj1&apos;) ... 15. 遍历 map.forEach(function(value,index){ console.log(index + &quot;:&quot; +value) }) 16. 注意事项 map.set({},&quot;哈哈&quot;) map.set({},&quot;呵呵&quot;) // 会添加两条数据 123456789 &gt;### Symbol**特点*** ES5的对象属性都是字符串，容易造成属性名冲突* ES6引入新的原始数据类型Symbol，表示独一无二的值1. 定义 let smb1 = Symbol(); let smb2 = Symbol(); console.log(smb1 === smb2) // false console.log(typeof smb1) // symbol 12. 描述 let str1 = Symbol(&apos;name&apos;); let str2 = Symbol(&apos;name&apos;); console.log(str1) // Symbol(name) console.log(str2) // Symbol(name) console.log(str1 === str2) // false 13. 对象的属性名 const obj = {}; // obj.name = &apos;张三&apos;; // obj.name = &apos;李四&apos;; obj[Symbol(&apos;name&apos;)] = &apos;张三&apos;; obj[Symbol(&apos;name&apos;)] = &apos;李四&apos;; console.log(obj); 12345 ![symbol.jpg](symbol.jpg) &gt;### Class 语法糖1. 构造函数 function Person(name,age){ this.name = name; this.age = age; } Person.prototype = { constructor: Person, Say:function(){ console.log(&quot;我的名字叫&quot; + this.name + &quot;，今年&quot; + this.age + &quot;岁&quot;) } } let person = new Person(&apos;小明&apos;,18); console.log(person) 12. 通过class面向对象 class Person{ constructor(name,age){ this.name = name; this.age = age; } Say:function(){ console.log(&quot;我的名字叫&quot; + this.name + &quot;，今年&quot; + this.age + &quot;岁&quot;) } } 1234 &gt;### 内置对象1. 模板字符串 `` &lt;style&gt; .test{color:red} &lt;/style&gt; let str = &apos;今天天气很好&apos;; let className = &apos;test&apos;; let html = ` &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&apos;$(className)&apos;&gt;${str}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;`; 1232. 数组的拓展 * Array.form // 把伪数组等转换成正式的数组 let allList = document.getElementsByTagName(&quot;li&quot;); //这是一个伪数组 console.log(allList); console.log(Array.isArray(allList)) // false console.log(Array.from(allList)) console.log(Array.isArray(allList)) // true 1* Array.of console.log(Array.of(1,2,3,4)) // [1,2,3,4] console.log(Array.of(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;)) // [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;] 12343. 对象的拓展 * key和value是一样的时候，写一个就够了 let name = &quot;张三&quot;; let age = &quot;18&quot;; /*let obj = { name: name, age:age }*/ let obj = { name, age } 1* Object.assign() //多个对象合成一个对象 let obj = {name:&apos;张三&apos;}; let obj1 = {age:18}; let obj2 = {sex:&apos;男&apos;}; Object.assign(obj, obj1, obj2) 12 &gt;### 延展操作符 let str = &apos;天气很好&apos;; let strArr = [...str] console.log(strArr) // [&apos;天&apos;,&apos;气&apos;,&apos;很&apos;,&apos;好&apos;] 1 // 数组去重 let myArr = [1,2,3,4,5,2,3]; console.log([...new Set(myArr)]) // [1,2,3,4,5] 1234 &gt;### 函数的拓展1. 形参设置默认值 /*function sum(num1,num2){ num1 = num1 || 10; num2 = num2 || 20 console.log(num1 + num2) }*/ function sum(num1 = 10,num2 = 20){ console.log(num1 + num2) } sum(); 12. 参数形式：延展操作符 /*function sum(){ let result = 0; for (let value of arguments){ result += value; } return result; } console.log(sum(10,20,30,40)) */ function sum(name,sex,...nums){ let result = 0; console.log(name); console.log(sex); for (let value of nums){ result += value; } return result; } console.log(sum(&apos;张三&apos;,&apos;男&apos;,10,20,30,40)) //参数多样化的传递 13. 箭头函数 ()=&gt;&#123;&#125; 解决了this指向的问题 /* function (){} */ let sum = (num1,num2)=&gt;{return num1 + num2;}; let arr = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]; arr.forEach((value,index)=&gt;{ console.log(index + &quot;;&quot; +value); }); function demo(){ setTimeout(function (){ console.log(this); // 这里指向的是window },1000); setTimeout(()=&gt;{ console.log(this); // 这里指向的obj },1000) } let obj = {}; demo.call(obj) ```","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/younghf.github.io/tags/ES6/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"CSS布局","slug":"CSS布局","date":"2017-12-06T07:36:53.000Z","updated":"2017-12-06T15:13:48.698Z","comments":true,"path":"2017/12/06/CSS布局/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/06/CSS布局/","excerpt":"","text":"内容包括： 布局简介、display(水平居中、居中导航)、position(轮播头图、固定顶栏、遮罩、三行自适应布局)、float(两列布局)、flex(三行两列自适应) 布局属性： Display:设置元素的显示方式 语法：display：none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex 默认值：inline 取值： none： 隐藏对象。与visibility 属性的hidden 值不同，其不为被隐藏的对象保留其物理空间 inline： 指定对象为内联元素。 block： 指定对象为块元素。 list-item： 指定对象为列表项目。 inline-block： 指定对象为内联块元素。（CSS2） table： 指定对象作为块元素级的表格。类同于html 标签&lt;table&gt;（CSS2） inline-table： 指定对象作为内联元素级的表格。类同于html 标签&lt;table&gt;（CSS2） table-caption： 指定对象作为表格标题。类同于html 标签&lt;caption&gt;（CSS2） table-cell： 指定对象作为表格单元格。类同于html 标签&lt;td&gt;（CSS2） table-row： 指定对象作为表格行。类同于html 标签&lt;tr&gt;（CSS2） table-row-group： 指定对象作为表格行组。类同于html 标签&lt;tbody&gt;（CSS2） table-column： 指定对象作为表格列。类同于html 标签&lt;col&gt;（CSS2） table-column-group： 指定对象作为表格列组显示。类同于html 标签&lt;colgroup&gt;（CSS2） table-header-group： 指定对象作为表格标题组。类同于html 标签&lt;thead&gt;（CSS2） table-footer-group： 指定对象作为表格脚注组。类同于html 标签&lt;tfoot&gt;（CSS2） run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3） box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） Display: Block（块级元素） 默认宽度为父元素宽度 可设置宽高 换行显示 默认的display:block 元素有：div,h1-h6,p,ul,form,…… Display: inline（行内元素） 默认宽度为内容宽度 不可设置宽高 同行显示 Display:block 与display:inline 比较 display 默认宽度 可设置宽高 起始位置 block 父元素宽度 是 换行 inline 内容宽度 否 同行 Display: inline-block（行内元素） 默认宽度为内容宽度 可设置宽高 同行显示 整块换行 默认display:inline-block 元素有：img,input,textarea,select,button,…… display:none 或visibility:hidden 隐藏一个元素可以通过把display 属性设置为”none”，或把visibility 属性设置为”hidden”。display 属性设置一个元素应如何显示，visibility 属性指定一个元素应可见还是隐藏。这两种方法会产生不同的结果。 visibility:hidden 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局. display:none 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 与Display 相关布局模式 块级元素水平居中 1margin:0 auto; 参考知识： 在CSS 中，html 中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有： &lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 常用的内联元素有： &lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 常用的内联块状元素有： &lt;img&gt;、&lt;input&gt; 解决内联元素（行内元素）间隙bug 问题行内元素之间会产生间隙bug 问题的场景： 当行内元素之间有“回车”、“tab”、“空格”时就会出现间隙。 解决方法： 写在一行，之间不要有空格之类的符号。 &lt;div&gt; &lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;span&gt;33333&lt;/span&gt;&lt;span&gt;44444&lt;/span&gt;&lt;em&gt;555555&lt;/em&gt; &lt;/div&gt; 使用font-size:0，设置内联元素的父元素字体大小为0，然后设置内联元素字体大小。 div{font-size:0;} a,span,em{font-size:16px;}/*div 为a、span、em 元素的父元素*/ 标签分开写，例如： &lt;div&gt; &lt;a&gt;1&lt;/a &gt; &lt;a&gt;2&lt;/a &gt; &lt;span&gt;33333&lt;/span &gt; &lt;span&gt;44444&lt;/span &gt; &lt;em&gt;555555&lt;/em&gt; &lt;/div&gt; 如何实现浏览器兼容版的inline-block 显示IE6,7 支持inline 元素转换成inline-block，但不支持block 元素转换成inline-block，所以非inline 元素在IE6,7 下要转换成inline-block，需先转换成inline，然后触发hasLayout，以此来获得和inline-block 类似的效果；你可以这样： 全兼容的inline-block： div { display: inline-block; *display: inline; *zoom: 1; } 对应的脚本特性为display。 定位（position）: CSS 定位(Positioning) 属性允许你对元素进行定位。 定位的基本思想:它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。 CSS 定位机制 CSS 有三种基本的定位机制：普通流、浮动和绝对定位。 除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在(X)HTML 中的位置决定。块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。 CSS 定位属性 Position-设置定位方式 Top,right,bottom,left,z-index-设置元素边缘距离参照物边缘的距离 CSS 定位属性允许你对元素进行定位。 属性 描述 position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。 top 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 right 定义了定位元素右外边距边界与其包含块右边界之间的偏移。 bottom 定义了定位元素下外边距边界与其包含块下边界之间的偏移。 left 定义了定位元素左外边距边界与其包含块左边界之间的偏移。 overflow 设置当元素的内容溢出其区域时发生的事情。 clip 设置元素的形状。元素被剪入这个形状之中，然后显示出来。 vertical-align 设置元素的垂直对齐方式。 z-index 设置元素的堆叠顺序。 CSS position 属性 通过使用position 属性，我们可以选择4 种不同类型的定位，这会影响元素框生成的方式。 * static元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 * relative元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 * absolute元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 * fixed元素框的表现类似于将position 设置为absolute，不过其包含块是视窗本身。 Z-index -设置元素在z 轴上的排序 z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 元素可拥有负的z-index 属性值。 Z-index 仅能在定位元素上奏效（例如position:absolute;） Z-index 栈 Float 浮动: 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 float 属性定义元素在哪个方向浮动. 以往这个属性总应用于图像，使文本围绕在图像周围，不过在CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 语法：float：none | left | right Float 浮动基本特征： float 的元素在同一文档流 float 元素半脱离文档流 对元素，脱离文档流；对内容，在文档流。 Clear-清除浮动： 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用clear 属性。clear 属性规定元素的哪一侧不允许其他浮动元素。 语法： clear：none | left | right | both 应用于(浮动元素)后续元素； 应用于块级元素； 使用方式： 增加空白元素 Clearfix 代码： .clearfix:after{ Content:”.”;display:block;clear:both;height:0; Overflow:hidden;visibility:hidden;} .clearfix{zoom:1;} Flex 伸缩布局: Flex Terms-基本概念： Flex 容器（flex container）： 采用Flex 布局的元素，称为Flex 容器（flex container），简称”容器”。 Flex 项目（flex item）: Flex 容器的所有子元素自动成为容器成员，称为Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 创建flex container 容器： Display:flex Flex items（flex 项目） 在文档流中的子元素是弹性子元素 弹性布局特性： 与方向有关： flex-direction Flex-wrap Flex-flow order 与弹性有关： Flex-basis Flex-grow Flex-shrink flex 与对齐有关： Justify-content Align-items Align-self Align-content Flex-direction: 决定主轴的方向（即项目的排列方向） Flex-direction:row|row-reverse|column|column-reverse 它可能有4 个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 Flex-wrap: 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。 Flex-wrap:nowrap|wrap|wrap-reverse 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 Flex-flow: flex-flow 属性是flex-direction 属性和flex-wrap 属性的简写形式，默认值为row nowrap。 Flex-flow:：&lt;’ flex-direction ‘&gt; || &lt;’ flex-wrap ‘&gt; Order: order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 Order: Initial:0 (初始值为0) Flex-basis flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex-basis: | auto; / default auto / 设置flex item 的初始宽/高 它可以设为跟width 或height 属性一样的值（比如350px），则项目将占据固定空间。 Flex-grow: flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。设置元素所能分配到的空余空间的比例。 Flex-grow: Initial:0 默认情况下，flex-grow:0,flex-item 项目不占据额外空间。 如果只设置一个flex-item 项目的flex-grow 为1，则它将占据剩余空间。 如果一个项目的flex-grow 属性为2，一个项目为1，则前者占据的剩余空间比后者多一倍。 计算方法：flex-basis + flow-grow/sum(flow-grow) * remain 示例：b,c 将按照1:3 的比率分配剩余空间 123&lt;ul class=&quot;flex&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;/ul&gt; CSS Code: .flex&#123;display:flex;width:600px;margin:0;padding:0;list-style:none;&#125; .flex li:nth-child(1)&#123;width:200px;&#125; .flex li:nth-child(2)&#123;flex-grow:1;width:50px;&#125; .flex li:nth-child(3)&#123;flex-grow:3;width:50px;&#125; flex-grow 的默认值为0，如果没有显示定义该属性，是不会拥有分配剩余空间权利的。 本例中b,c 两项都显式的定义了flex-grow，flex 容器的剩余空间分成了4 份，其中b 占1份，c 占3 分，即1:3 flex 容器的剩余空间长度为：600-200-50-50=300px，所以最终a,b,c 的长度分别为： a: 200+(300/4*0)=200px b: 50+(300/4*1)=125px a: 50+(300/4*3)=275px Flex-shrink: flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 Flex-shrink: Initial:1 如果所有项目的flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 计算方法：flex-basis + flow-shrink/sum(flow-shrink) * remain 示例：a,b,c 将按照1:1:3 的比率来收缩空间 &lt;ul class=&quot;flex&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;/ul&gt; CSS Code: .flex{display:flex;width:400px;margin:0;padding:0;list-style:none;} .flex li{width:200px;} .flex li:nth-child(3){flex-shrink:3;} flex-shrink 的默认值为1，如果没有显示定义该属性，将会自动按照默认值1 在所有因子相加之后计算比率来进行空间收缩。 本例中c 显式的定义了flex-shrink，a,b 没有显式定义，但将根据默认值1 来计算，可以看到总共将剩余空间分成了5 份，其中a 占1 份，b 占1 份，c 占3 分，即1:1:3 我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px 需要被a,b,c 消化 通过收缩因子，所以加权综合可得2001+2001+200*3=1000px； 于是我们可以计算a,b,c 将被移除的溢出量是多少： a 被移除溢出量：(200*1/1000)*200，即约等于40px b 被移除溢出量：(200*1/1000)*200，即约等于40px c 被移除溢出量：(200*3/1000)*200，即约等于120px 最后a,b,c 的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px Flex flex 属性是flex-grow, flex-shrink 和flex-basis 的简写，默认值为0 1 auto。后两个属性可选。 Flex: [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]|none Initial:0 1 auto 该属性有两个快捷值：auto (1 1 auto) 和none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 取值： none： none 关键字的计算值为: 0 0 auto &lt;’ flex-grow ‘&gt;： 用来指定扩展比率，即剩余空间是正值时此「flex 子项」相对于「flex 容器」里其他「flex 子项」能分配到空间比例。在「flex」属性中该值如果被省略则默认为「1」 &lt;’ flex-shrink ‘&gt;： 用来指定收缩比率，即剩余空间是负值时此「flex 子项」相对于「flex 容器」里其他「flex 子项」能收缩的空间比例。在收缩的时候收缩比率会以伸缩基准值加权在「flex」属性中该值如果被省略则默认为「1」 &lt;’ flex-basis ‘&gt;： 用来指定伸缩基准值，即在根据伸缩比率计算出剩余空间的分布之前，「flex 子项」长度的起始数值。在「flex」属性中该值如果被省略则默认为「0%」在「flex」属性中该值如果被指定为「auto」，则伸缩基准值的计算值是自身的&lt;’ width’&gt; 设置，如果自身的宽度没有定义，则长度取决于内容。 如果缩写「flex: 1」, 则其计算值为「1 1 0%」 如果缩写「flex: auto」, 则其计算值为「1 1 auto」 如果「flex: none」, 则其计算值为「0 0 auto」 如果「flex: 0 auto」或者「flex: initial」, 则其计算值为「0 1 auto」，即「flex」初始值 Justify-content justify-content: flex-start | flex-end | center | space-between | space-around 定义了项目在主轴(main-axis)上的对齐方式。 它可能取5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 Align-items align-items: flex-start | flex-end | center | baseline | stretch 定义项目在交叉轴(辅轴，cross-axis)上如何对齐。 它可能取5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 Align-self align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items 属性。 默认值为auto，表示继承父元素的align-items 属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch 设置单个flex item 在cross-axis 方向上对齐方式。 Align-content align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch 设置cross-axis 方向上行对齐方式 该属性可能取6 个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 关于flex 布局，可参看资源： http://www.xifengxx.com/seo/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/1408.html","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"http://yoursite.com/younghf.github.io/tags/CSS布局/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"CSS背景","slug":"CSS背景","date":"2017-12-06T05:43:19.000Z","updated":"2017-12-06T14:51:19.737Z","comments":true,"path":"2017/12/06/CSS背景/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/06/CSS背景/","excerpt":"","text":"background 属性 值描述 CSS background-color 规定要使用的背景颜色。 1 background-position 规定背景图像的位置。 1 background-size 规定背景图片的尺寸。 3 background-repeat 规定如何重复背景图像。 1 background-origin 规定背景图片的定位区域。 3 background-clip 规定背景的绘制区域。 3 background-attachment 规定背景图像是否固定或者随着页面的其余部分滚动。 1 background-image 规定要使用的背景图像。 1 inherit 规定应该从父元素继承background 属性的设置。 1 1. 背景颜色-background-color默认值：transparent ，即背景是透明的。 2. 背景图像-background-imagebackground-image:url(“../App_images/lesson/run_cj/one piece.jpg”); 注意：引号也可以不写 3. background-repeat语法： background-repeat：&lt;repeat-style&gt; [ , &lt;repeat-style&gt; ]* &lt;repeat-style&gt; = repeat-x | repeat-y | [repeat | no-repeat | space | round]{1,2} 默认值：repeat 属性值 说明 no-repeat 表示不平铺 repeat 默认值，表示在水平方向（x 轴）和垂直方向（y 轴）同时平铺 repeat-x 表示在水平方向（x 轴）平铺 repeat-y 表示在垂直方向（y 轴）平铺 space 背景图像以相同的间距平铺且填充满整个容器或某个方向。 round 背景图像自动缩放(不是等比的)直到适应且填充满整个容器。 设置或检索对象的背景图像如何铺排填充。必须先指定&lt;’ background-image ‘&gt; 属性。 允许提供2 个参数，如果提供全部2 个参数，第1 个用于横向，第二个用于纵向。 如果只提供1 个参数，则用于横向和纵向。特殊值repeat-x 和repeat-y 除外，因为repeat-x 相当于repeat no-repeat，repeat-y 相当于no-repeat repeat，即其实repeat-x 和repeat-y 等价于提供了2 个参数值. 4. background-position 属性语法：background-position：&lt;position&gt; [ , &lt;position&gt; ]* &lt;position&gt; = [ left | center | right | top | bottom | &lt;percentage&gt; | &lt;length&gt; ] | [ left| center | right | &lt;percentage&gt; | &lt;length&gt; ] [ top | center | bottom | &lt;percentage&gt; |&lt;length&gt; ] | [ center | [ left | right ] [ &lt;percentage&gt; | &lt;length&gt; ]? ] &amp;&amp; [ center | [ top| bottom ] [ &lt;percentage&gt; | &lt;length&gt; ]? ] 默认值：0% 0%，效果等同于left top 5. background-attachment 属性在CSS 中，使用背景附件属性background-attachment 可以设置背景图像是随对象滚动还是固定不动。 语法： background-attachment： [ , ]* = fixed | scroll | local 默认值：scroll fixed： 背景图像相对于窗体固定。 scroll： 背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起滚动。 local： 背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容。（CSS3） 6. background-size 属性在CSS3 中，我们可以使用background-size 属性来设置背景图片的大小，这使得我们可以在不同的环境中重复使用背景图片。 语法：background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain 关键字 说明 cover 即“覆盖”，将背景图片以等比缩放来填充整个容器元素 contain 即“容纳”，将背景图片等比缩放至某一边紧贴容器边缘为止 auto 默认值，不改变背景图片的原始高度和宽度 &lt;长度值&gt; 成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放 &lt;百分比&gt; 0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上 7. background-origin 属性在CSS3 中，我们可以使用background-origin 属性来设置元素背景图片平铺的最开始位置。 语法：background-origin ： border-box | padding-box | content-box; 属性值 说明 border-box 表示背景图片是从边框开始平铺 padding-box 表示背景图片是从内边距开始平铺（默认值） content-box 表示背景图片是从内容区域开始平铺 总结：background-origin 属性往往都是配合background-position 属性来使用，其中background-origin 属性规定background-position 属性相对于什么位置来定位。浏览器默认采用“background-position:top left;”。因此不管background-origin 属性值如何变化，背景图片都是从“左上”开始平铺。 效果如下： 注意：如果背景不是no-repeat，这个属性无效，它会从边框开始显示。 8. background-clip 属性在CSS3 中，使用background-clip 属性来将背景图片根据实际需要进行剪切。 语法：background-clip ： border-box | padding-box | content-box | no-clip 属性值 说明 border-box 默认值，表示从边框border 开始剪切 padding-box 表示从内边距padding 开始剪切 content-box 表示从内容区域content 开始剪切 No-clip 不裁切，和参数border-box 显示同样的效果 background-clip 属性指定了背景在哪些区域可以显示，但与背景开始绘制的位置（即background-origin 属性）无关。背景绘制的位置可以出现在不显示背景的区域。这就相当于背景图片被不显示背景的区域裁剪了一部分一样。 9. Background 缩写多重背景(multiple backgrounds)，也就是CSS2 里background 的属性外加origin、clip 和size 组成的新background 的多次叠加，缩写时为用逗号隔开的每组值。 用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。 语法缩写如下： background ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [backgroundclip] | [background-origin],... 可以把上面的缩写拆解成以下形式： background-image:url1,url2,...,urlN; background-repeat : repeat1,repeat2,...,repeatN; backround-position : position1,position2,...,positionN; background-size : size1,size2,...,sizeN; background-attachment : attachment1,attachment2,...,attachmentN; background-clip : clip1,clip2,...,clipN; background-origin : origin1,origin2,...,originN; background-color : color; 注意： 用逗号隔开每组background 的缩写值； 如果有size 值，需要紧跟position 并且用”/“ 隔开； 如果有多个背景图片，而其他属性只有一个（例如background-repeat 只有一个），表明所有背景图片应用该属性值。 background-color 只能设置一个。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"CSS背景","slug":"CSS背景","permalink":"http://yoursite.com/younghf.github.io/tags/CSS背景/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"CSS盒模型","slug":"CSS盒模型","date":"2017-12-05T08:22:53.000Z","updated":"2017-12-06T07:27:44.908Z","comments":true,"path":"2017/12/05/CSS盒模型/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/05/CSS盒模型/","excerpt":"","text":"每个元素都可以看成一个盒子，盒子模型是由content（内容）、padding（内边距）、margin（外边距）和border（边框）这四个属性组成的。此外，在盒子模型中，还有宽度width和高度height 两大辅助性属性。 下图为一个CSS 盒子模型的内部结构： 属性 说明 border （边框）元素边框 margin （外边距）用于定义页面中元素与元素之间的距离 padding （内边距）用于定义内容与边框之间的距离 content （内容）可以是文字或图片 以上属性的就不赘述了，请自行查阅相关资料。 CSS 外边距合并 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。请看下图： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。请看下图： 尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并： 如果这个外边距遇到另一个元素的外边距，它还会发生合并： 注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 参考资料：外边距margin 合并（塌陷），请查看以下资料：https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin_collapsing http://www.w3help.org/zh-cn/kb/006/ Border-radius—圆角边框 常用的CSS3 边框属性： 属性 说明 border-radius 圆角效果 border-colors 多色边框 border-image 边框背景 box-shadow 边框阴影 border-radius 属性 语法：border-radius:长度值; 说明：长度值可以是px、百分比、em 等。 Border-radius 属性设置长度值顺序：“左上角、右上角、右下角和左下角”。 border-radius 画实心半圆和实心圆 实心半圆 实心半圆分为：实心上半圆、实心下半圆、实心左半圆、实心右半圆。我们只要掌握制作一个方向的实心半圆的方法，其他方向的实心半圆就可以轻松实现，因为原理都一样。假如我们要制作实现上半圆，实现方法：把高度(height)设为宽度（width）的一半，并且只设置左上角和右上角的圆角半径与元素的高度一致，而右下角和左下角的圆角半径设置为0。 1width:200px; height:100px; border:1px solid red; border-radius:100px 100px 0 0; 实心圆 在CSS3 中，使用border-radius 属性实现实心圆方法：把宽度（width）与高度(height)值设置为一致（也就是正方形），并且四个圆角值都设置为它们值的一半。 1width:100px; height:100px; border:1px solid red; border-radius:50px; **border-radius 属性派生子属性** border-radius 属性可以分开，分别为四个角设置相应的圆角值，分别是： * border-top-right-radius：右上角； * border-bottom-right-radius：右下角； * border-bottom-left-radius：左下角； * border-top-left-radius：左上角； box-shadow 边框阴影 语法：box-shadow：x-shadow y-shadow blur spread color inset; 说明： x-shadow：设置水平阴影的位置（X 轴），可以使用负值； y-shadow：设置垂直阴影的位置（y 轴），可以使用负值； blur：设置阴影模糊半径； spread：阴影扩展半径，设置阴影的尺寸；这个参数可选，缺省时值为0。 color：设置阴影的颜色； inset：这个参数默认不设置。默认情况下为外阴影，inset 表示内阴影。（这个值可以放在开头位置。） outset: 默认值 技巧：当水平阴影位置x-shadow 和垂直阴影位置y-shadow 都为0 时，阴影都向外发散或者都向内发散。 注意：阴影不占空间 Overflow 属性 overflow 属性规定当内容溢出元素框时发生的事情. 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承overflow 属性的值。 Box-sizing 属性 语法： box-sizing: content-box|border-box|inherit; 属性值 属性值说明 content-box 默认值，其让元素维持W3C 的标准盒模型，也就是说元素的宽度和高度（width/height）等于元素边框宽度（border）加上元素内距（padding）加上元素内容宽度或高度（content width/ height），也就是element width/height = border + padding + content width / height border-box 重新定义CSS2.1 中盒模型组成的模式，让元素维持IE 传统的盒模型（IE6 以下版本和IE6-7 怪异模式），也就是说元素的宽度或高度等于元素内容的宽度或高度。从上面盒模型介绍可知，这里的内容宽度或高度包含了元素的border、padding、内容的宽度或高度（此处的内容宽度或高度＝盒子的宽度或高度—边框—内距）。 inherit 使元素继承父元素的盒模型模式 其中最为关键的是box-sizing 中content-box 和border-box 两者的区别，他们之间的区别可以通过下图来展示，其对盒模型的不同解析： 参考资料： box-sizing 理解： http://www.w3cplus.com/content/css3-box-sizing CSS 属性的浏览器兼容性：http://caniuse.com/ outline 轮廓 轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。其属性规定元素轮廓的样式、颜色和宽度。 属性 描述 CSS outline 在一个声明中设置所有的轮廓属性。 2 outline-color 设置轮廓的颜色。 2 outline-style 设置轮廓的样式。 2 outline-width 设置轮廓的宽度。 2","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"CSS盒模型","slug":"CSS盒模型","permalink":"http://yoursite.com/younghf.github.io/tags/CSS盒模型/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"CSS文本","slug":"CSS文本","date":"2017-12-05T04:01:11.000Z","updated":"2017-12-06T15:18:13.748Z","comments":true,"path":"2017/12/05/CSS文本/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/05/CSS文本/","excerpt":"","text":"CSS 字体属性 属性 描述 font 简写属性。作用是把所有针对字体的属性设置在一个声明中。 font-family 设置字体系列。 font-size 设置字体的尺寸。 font-style 设置字体风格。 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 设置字体的粗细。 以上具体的属性介绍在此不再赘述。 如上图，灰色的属性表示不常用，其中font-size、font-family为必填项，所以最后两种缩写的方式是不起作用的。 Line-height–行间距（行高） line-height: normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; 注意：&lt;percentage&gt;是先计算后继承，是直接继承 Color 颜色 检索或设置对象的文本颜色。无默认值。 可以使用Color Name(颜色名称), HEX（十六进制颜色）, RGB, RGBA, HSL, HSLA, transparent来指定color。 注意，用颜色名称指定color 可能不被一些浏览器接受。 color 属性值被间接用来提供一个中间值currentColor 以供其他接受颜色值的属性使用。 示例：12div &#123; border: 10px solid; color: red;&#125; 如上代码，没有定义边框的颜色，但定义了color 的颜色为red，那么这时red 将会作为一个间接值currentColor 提供给边框颜色属性，所以最终边框色也为red。 Text-align 文本对齐方式 text-align 属性规定元素中的文本的水平对齐方式。只能针对文本文字和img 标签，对其他标签无效。 该属性通过指定行框与哪个点对齐，从而设置块级元素内文本的水平对齐方式。通过允许用户代理调整行内容中字母和字之间的间隔，可以支持值justify；不同用户代理可能会得到不同的结果。 属性 描述 默认值 如果direction 属性是ltr，则默认值是left；如果direction 是rtl，则为right。 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 inherit 规定应该从父元素继承text-align 属性的值。 vertical-align 垂直对齐方式 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 值 描述 baseline 默认。元素放置在父元素的基线上。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 top 把元素的顶端与行中最高元素的顶端对齐 text-top 把元素的顶端与父元素字体的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 把元素的顶端与行中最低的元素的顶端对齐。 text-bottom 把元素的底端与父元素字体的底端对齐。 length % 使用”line-height” 属性的百分比值来排列此元素。允许使用负值。 inherit 规定应该从父元素继承vertical-align 属性的值。 Text-indent 设置首行缩进 中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现： 1p&#123;text-indent:2em;&#125; White-space white-space 属性设置如何处理元素内的空白（空白符）。 可能值 描述 normal 默认。空白会被浏览器忽略。丢掉多余的空白符，换行字符（回车）会转换为空格，一行中多个空格的序列也会转换为一个空格。 pre 空白会被浏览器保留。其行为方式类似HTML 中的&lt;pre&gt; 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到&lt;br&gt; 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承white-space 属性的值。 white-space 属性的行为： 值 空白符 换行符 自动换行 pre-line 合并 保留 允许 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 Word-wrap word-wrap 属性允许长单词或 URL 地址换行到下一行。一般情况下，如果你开发的是英文网站，就很有可能用到word-wrap 这个属性了。 语法: word-wrap: normal | break-word; Word-break 设置或检索对象内文本的字内换行行为。 对于解决防止页面中出现连续无意义的长字符打破布局，应该使用break-all 属性值； 语法： word-break：normal | keep-all | break-all 默认值：normal 取值： normal：依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。 keep-all：与所有非亚洲语言的normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 break-all：该行为与亚洲语言的normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本，比如使连续的英文字母间断行。 Text-decoration -文本修饰 属性值 说明 none 默认值，可以用这个属性值也可以去掉已经有下划线或删除线或顶划线的样式 underline 下划线 line-through 删除线 overline 顶划线 underline 会对元素加下划线，就像HTML 中的U 元素一样。overline 的作用恰好相反，会在文本的顶端画一个上划线。值line-through 则在文本中间画一个贯穿线，等价于HTML 中的S 和strike 元素。 none 值会关闭原本应用到一个元素上的所有装饰。通常，无装饰的文本是默认外观，但也不总是这样。 例如，链接默认地会有下划线。如果您希望去掉超链接的下划线，可以使用以下CSS 来做到这一点： 1a &#123;text-decoration: none;&#125; Text-shadow 文字阴影 语法：text-shadow:x-offset y-offset blur color; 说明： x-offset：（水平阴影）表示阴影的水平偏移距离，单位可以是px、em 或者百分比等。如果值为正，则阴影向右偏移；如果值为负，则阴影向左偏移； y-offset：（垂直阴影）表示阴影的垂直偏移距离，单位可以是px、em 或者百分比等。如果值为正，则阴影向下偏移；如果值为负，则阴影向上偏移； blur：（模糊距离）表示阴影的模糊程度，单位可以是px、em 或者百分比等。blur 值不能为负。如果值越大，则阴影越模糊；如果值越小，则阴影越清晰。当然，如果不需要阴影模糊效果，可以把blur 值设置为0； color：（阴影的颜色）表示阴影的颜色。 在CSS3 中，可以使用text-shadow 属性来给文字指定多个阴影，并且针对每个阴影使用不同的颜色。也就是说，text-shadow 属性可以为一个以英文逗号隔开的“值列表”，如：text-shadow:0 0 4px white, 0 -5px 4px #ff3, 2px -10px 6px #fd3;当text-shadow 属性值为“值列表”时，阴影效果会按照给定的值顺序应用到该元素的文本上，因此有可能出现互相覆盖的现象。但是text-shadow 属性永远不会覆盖文本本身，阴影效果也不会改变边框的尺寸。 text-stroke 属性 语法：text-stroke:宽度值颜色值; 在CSS3 中，我们可以使用text-stroke 属性为文字添加描边效果。这个描边效果，说白了就是给文字添加边框。 text-overflow 属性 在CSS3 中，文本溢出text-overflow 用于设置是否使用一个省略标记（…）标示对象内文本的溢出。 属性值 说明 ellipsis 当对象内文本溢出时显示省略标记（…） clip 当对象内文本溢出时不显示省略标记（…），而是将溢出的部分裁切掉 单独使用text-overflow 属性是无法得到上面图1 效果的。因为text-overflow 属性只是说明文字溢出时用什么方式显示，要实现溢出时产生省略号效果，还须定义2 个内容： （1）white-space:nowrap;（强制文本在一行内显示）； （2）overflow:hidden;（溢出内容为隐藏）； 下面是实现文字溢出时产生省略号效果的完整语法： text-overflow:ellipsis; overflow:hidden; white-space:nowrap; 这3个属性是必须一起使用才会有效果。 Cursor 属性 在CSS 中，使用cursor 属性来定义鼠标的样式。 语法：cursor:属性值; cursor 属性取值如下，默认值为default。在实际开发中，我们一般只用到“default”和“pointer”这两个属性值，其他的一般都很少用得上，无需记忆。 Inherit 属性 该值使得属性能够继承祖先设置。 inherit 属于CSS-wide 关键字，这表示所有的属性都可以接受该值。 如何让一个不具备继承特性的属性可以继承父元素的定义？ 示例代码： div { position: relative; } div a { position: inherit; } 上述代码，超链接a 将会继承父元素的position 定义，也会定义为relative。常用的CSS 属性继承性：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"CSS文本","slug":"CSS文本","permalink":"http://yoursite.com/younghf.github.io/tags/CSS文本/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"CSS选择器","slug":"CSS选择器","date":"2017-12-01T07:42:19.000Z","updated":"2017-12-01T16:33:25.437Z","comments":true,"path":"2017/12/01/CSS选择器/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/01/CSS选择器/","excerpt":"","text":"CSS 选择器 选择器，说白了就是用一种方式把你想要的那一个标签选中！把它选中了，你才能操作这个标签的CSS 样式。CSS 有很多把你所需要的标签选中的方式，这些不同的方式就是不同的选择器。 选择器的不同，在于它选择方式不同，但是他们的目的都是相同的，那就是把你需要的标签选中，然后让你定义该标签的CSS 样式。当然，你也有可能会用某一种选择器代替另一种选择器，这仅仅是由于选择方式不一样罢了，目的还是一样的。 标签选择器 标签选择器其实就是html 代码中的标签。例如下面代码： 1p&#123;font-size:12px;line-height:1.6em;&#125; 上面的css 样式代码的作用：为p 标签设置12px 字号，行间距设置1.6em 的样式。 类选择器 语法：.选择器名称{css 样式代码;} 1.selector&#123;color:red;&#125; 注意： 英文圆点开头 其中类选器名称可以任意起名（但不要起中文噢） ID 选择器 语法：#选择器名称{css 样式代码;} 1#selector&#123;color:red;&#125; 类和ID 选择器的区别 相同点：可以应用于任何元素 不同点： ID 选择器只能在文档中使用一次。与类选择器不同，在一个HTML 文档中，ID 选择器只能使用一次，而且仅一次。而类选择器可以使用多次。 可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID 选择器是不可以的（不能使用ID 词列表）。 通用选择器（通配符选择器） 通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html 中所有标签元素，如下使用下面代码使用html 中任意标签元素字体颜色全部设置为红色： 1*&#123;color:red;&#125; 属性选择器 选择器 描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute丨=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 实例展示： html 代码： 1&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF 文件&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt; &lt;a href=&quot;#&quot; title=&quot;我的title 是more&quot;&gt;我的title 是more&lt;/a&gt; css 代码: 1a[class^=icon]&#123; background: green; color:#fff; &#125; a[href$=pdf]&#123; background: orange; color: #fff; &#125; a[title*=more]&#123; background: blue; color: #fff; &#125; 结果显示： 伪类选择器 CSS 伪类用于向某些选择器添加特殊的效果。又叫伪类选择符，它允许给html 不存在的标签（标签的某种状态）设置样式，比如说我们给html 中一个标签元素的鼠标滑过的状态来设置字体颜色： 1a:hover&#123;color:red;&#125; 属性 描述 CSS :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定lang 属性的元素添加样式。 2 :enabled 匹配每个启用的元素（主要用于表单元素）。 3 :disabled 匹配每个禁用的元素（主要用于表单元素）。 3 :checked 匹配每个已被选中的 input 元素（只用于单选按钮和复选框）。 3 结构伪类选择器 是针对HTML 层次“结构”的伪类选择器。例如我们想要某一个父元素下面的第n 个子元素。 总结： “:first-child”是选择父元素下的第1 个子元素（不区分元素类型），而“:first-of-type”是选择父元素下某个元素类型的第1 个子元素（区分元素类型）。 UI 元素状态伪类选择器 UI，是用户界面（User Interface）的意思。所谓的UI 设计是指对软件的人机交互、操作逻辑、界面美观的综合设计。 UI 元素状态包括：可用、不可用、选中、未选中、获取焦点、失去焦点等。这些选择器的共同特征是：指定的样式只有当元素处于某种状态下时才起作用，在默认状态下不起作用。UI 元素状态伪类选择器大多数都是针对表单元素来使用的。 选择器 说明 E:focus 指定元素获得光标焦点时使用的样式 E:checked 选择E 元素中所有被选中的元素 E::selection 改变E 元素中被选择的网页文本的显示效果 E:enabled 选择E 元素中所有“可用”元素 E:disabled 选择E 元素中所有“不可用”元素 E:read-write 选择E 元素中所有“可读写”元素 E:read-only 选择E 元素中所有“只读”元素 E::before 在E 元素之前插入内容 E::after 在E 元素之后插入内容 CSS 伪元素选择器 选择器 说明 ::first-letter 向文本的第一个字母添加特殊样式 ::first-line 向文本的首行添加特殊样式 ::before 在元素之前添加内容 ::after 在元素之后添加内容 ::selection 改变元素中被选择的网页文本的显示效果 CSS 组合选择器 子选择器: 即大于符号(&gt;),用于选择指定标签元素的第一代子元素。如下代码： 1.food&gt;li&#123;border:1px solid red;&#125; 这行代码会使class 名为food 下的子元素li 加入红色实线边框。 包含(后代)选择器: 即加入空格,用于选择指定标签元素下的后辈元素。如下代码： 1.first span&#123;color:red;&#125; 请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“&gt;”进行选择。 **总结：** &gt;作用于元素的第一代后代，空格作用于元素的所有后代。 相邻选择器: 相邻选择器只会命中符合条件的相邻的兄弟元素，使用“+”号。 如：p+p{color:#f00;} 即设置与p 元素相邻的p 元素的颜色。 兄弟选择器 兄弟选择器会命中所有符合条件的兄弟元素，而不强制是紧邻的元素，使用“~”符号 如：p~p{color:#f00;} 群组选择器 群组选择器，就是同时对几个选择器进行相同的操作。 语法：h3,div,p,span{color:red;} CSS 继承 CSS 的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html 标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p 标签，这个颜色设置不仅应用p 标签，还应用于p 标签中的所有子元素文本，这里子元素为span 标签。 1p&#123;color:red;&#125; &lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 注意: 有一些css 样式是不具有继承性的。如border:1px solid red; 1p&#123;border:1px solid red;&#125; &lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 在上面例子中它代码的作用只是给p 标签设置了边框为1 像素、红色、实心边框线，而对于子元素span 是没用起到作用的。 CSS 优先级（特殊性） CSS 的优先级也可以称为CSS 的特殊性(specificity)或权值:对于每个样式表规则,浏览器都会计算选择器的特殊性,从而使元素属性声明在有冲突的情况下能够正确显示.有的时候我们为同一个元素设置了不同的CSS 样式代码，那么元素会启用哪一个CSS 样式呢? 我们来看一下面的代码： 1p&#123;color:red;&#125; .first&#123;color:green;&#125; &lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; p 和.first 都匹配到了p 这个标签上，那么会显示哪种颜色呢？green 是正确的颜色，那么为什么呢？是因为浏览器是根据权值来判断使用哪种css 样式的，权值高的就使用哪种css样式。 权值的规则：标签的权值为1，类选择符的权值为10，ID 选择符的权值最高为100。 例如下面的代码： 1p&#123;color:red;&#125; /*权值为1*/ p span&#123;color:green;&#125; /*权值为1+1=2*/ .warning&#123;color:white;&#125; /*权值为10*/ p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/ \\#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 注意：还有一个权值比较特殊—继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 如何改变CSS 的优先级？ 改变CSS 的先后顺序； 提升权重； 使用!important. CSS 层叠 层叠就是在html 文件中对于同一个元素可以有多个css 样式存在，当有相同权重的样式存在时，会根据这些css 样式的前后顺序来决定，处于最后面的css 样式会被应用。 如下面代码: 1p&#123;color:red;&#125; p&#123;color:green;&#125; &lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 最后p 中的文本会设置为green，这个层叠很好理解，理解为后面的样式会覆盖前面的样式。 所以前面的css 样式优先级就不难理解了： 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 重要性(!important) 我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？ 这时候我们可以使用!important 来解决。 如下代码： 1p&#123;color:red!important;&#125; p&#123;color:green;&#125; &lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 这时p 段落中的文本会显示的red 红色。 注意：!important 要写在分号的前面这里注意当网页制作者不设置css 样式时，浏览器会按照自己的一套样式来显示网页。并且用户也可以在浏览器中设置自己习惯的样式，比如有的用户习惯把字号设置为大一些，使其查看网页的文本更加清楚。这时注意样式优先级为： 浏览器默认的样式&lt; 网页制作者样式&lt; 用户自己设置的样式 但记住!important 优先级样式是个例外，权值高于用户自己设置的样式。 参考资料：http://www.quirksmode.org/css/selectors/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"CSS选择器","slug":"CSS选择器","permalink":"http://yoursite.com/younghf.github.io/tags/CSS选择器/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"CSS简介","slug":"CSS","date":"2017-12-01T05:22:24.000Z","updated":"2017-12-06T15:28:26.771Z","comments":true,"path":"2017/12/01/CSS/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/01/CSS/","excerpt":"","text":"CSS 简介 概念：CSS 全称为“层叠样式表(Cascading Style Sheets)”，它主要是用于定义HTML 内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 在HTML 中引入CSS 共有3 种方式： 外部样式表 1&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; &lt;/head&gt; 内部样式表 1&lt;style&gt; hr &#123;color:sienna;&#125; p &#123;margin-left:20px;&#125; body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125; &lt;/style&gt; 内联样式表 由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;This is a paragraph.&lt;/p&gt; 层叠次序 当同一个HTML 元素被不止一个样式定义时，会使用哪个样式呢？一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字4 拥有最高的优先权。 浏览器缺省设置 外部样式表 内部样式表（位于&lt;head&gt;标签内部） 内联样式（在HTML元素内部） 内联样式&gt; 标签中的样式声明&gt; 外部样式表中的样式声明(或者浏览器中的样式声明（缺省值）) 1提示:如果你使用了外部文件的样式在&lt;head&gt;中也定义了该样式，则内部样式表会取代外部文件的样式。注意上面所总结的优先级是有一个前提：内联式、嵌入式、外部式样式表中css 样式是在的相同权值的 情况下。 CSS语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器（selector）通常是您需要改变样式的HTML 元素。 每条声明(Declaration)由一个属性(property)和一个值(value)组成。在英文大括号“｛｝”中的的就是声明。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 浏览器私有属性 由于CSS3 很多属性尚未成为W3C 标准的一部分，因此每种内核的浏览器都只能识别带有自身私有前缀的CSS3 属性。我们在书写CSS3 代码时，需要在属性前加上浏览器的私有前缀，然后该种内核的浏览器才能识别相应的CSS3 属性。 私有前缀 对应的浏览器 -webkit- chrome 和 safari -moz- Firefox -ms- IE -o- opera 举个例子，假如我们想要使用CSS3 实现半径为10px 的圆角效果的话，就需要这么写： border-radius:10px; -webkit-border-radius:10px; /兼容chrome 和Safari/ -moz-border-radius:10px; /兼容Firefox/ -ms-border-radius:10px; /兼容IE/ -o-border-radius:10px; /兼容opera/ CSS 属性值定义参考资源： https://developer.mozilla.org/zh-CN/docs/Web/CSSValue_definition_syntaxhttp://www.dreamdu.com/css/property_value/ @规则及语法 @media 指定样式表规则用于指定的媒体类型和查询条件。 IE8 及以下只能实现CSS2 中的部分，即只可以设置媒体类型。 代码示例： 1@media screen and (width:800px)&#123; … &#125; @import url(example.css) screen and (width:800px); @keyframes 指定动画名称和动画效果。 定义动画时，简单的动画可以直接使用关键字from 和to，即从一种状态过渡到另一种状态： 代码示例： 12345@keyframes testanimations &#123; from &#123; opacity: 1; &#125; to &#123; opacity: 0; &#125; &#125;@keyframes testanimations &#123; from &#123; transform: translate(0, 0); &#125; 20% &#123; transform: translate(20px, 20px); &#125; 40% &#123; transform: translate(40px, 0); &#125; 60% &#123; transform: translate(60px, 20); &#125; 80% &#123; transform: translate(80px, 0); &#125; to &#123; transform: translate(100px, 20px); &#125; &#125;当然，也可以不使用关键字from 和to，而都使用&lt;percentage&gt;，如将上面的示例代码中的“from”、“to”分别换成“0%”、“100%”。 @font-face 设置嵌入HTML 文档的字体。 需要兼容当前的主流浏览器， 需同时使用TureTpe(.ttf) 、Web Open Font Format(.woff)、Embedded Open Type(.eot)、SVG(.svg)四种字体格式。 嵌入HTML 文档的字体是指将OpenType 字体（压缩的TrueType 字体）文件映射到客户端系统，用来提供HTML 文档使用该字体，或取代客户端系统已有的同名字体。即让客户端显示客户端所没有安装的字体。 .eot(Embedded Open Type)为IE 的私有字体格式。Safari3.1 开始支持.ttf(TrueType)和.otf(OpenType)。未来.woff(Web Open Font Format)将会取代.ttf(TrueType)和.otf(OpenType)两种字体格式 示例代码： 12345@font-face &#123; font-family: &apos;diyfont&apos;; src: url(&apos;diyfont.eot&apos;); /* IE9+ */ src: url(&apos;diyfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;diyfont.woff&apos;) format(&apos;woff&apos;), /*chrome、firefox */ url(&apos;diyfont.ttf&apos;) format(&apos;truetype&apos;), /*chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&apos;diyfont.svg#fontname&apos;) format(&apos;svg&apos;); /* iOS 4.1- */ &#125; 另外， 还有其他几种@ 规则， 如@import/@charset/@namespace/@page/@supports/@document 等，这几类规则用的比较少，具体可以查看CSS 参考手册：http://www.css88.com/book/css/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/younghf.github.io/tags/CSS/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"HTML标签","slug":"html","date":"2017-12-01T04:44:27.000Z","updated":"2017-12-01T06:52:51.736Z","comments":true,"path":"2017/12/01/html/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/12/01/html/","excerpt":"","text":"HTML常用标签汇总 关于各类标签及其用法，参考下面网站链接：HTML 参考手册：http://www.runoob.com/tags/html-reference.htmlHTML 字符实体参考手册：http://www.runoob.com/tags/ref-entities.htmlHTML有许多不同的版本，在此只介绍HTML5，主流浏览器都兼容HTML5 的新标签，对于IE8 及以下版本不认识HTML5 的新元素，可以使用JavaScript 创建一个没用的元素来解决，例如：&lt;script&gt;document.createElement(“header”);&lt;/script&gt;，也可以使用shiv 来解决兼容性问题，详情可参考HTML5 Shiv。 标签规则 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如&lt;b&gt; 和&lt;/b&gt;（ 当然也有例外，比如表示换行的单标签：&lt;/br&gt; ） 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 标签书写规范 标签统一用小写 属性值用双引号 嵌套缩进 HTML 常用属性（全局属性） id class style title 具体内容，可以参考：HTML 全局属性：http://www.runoob.com/tags/ref-standardattributes.html HTML 标签语义化： 标签的用途：语义化，让网页更好的被搜索引擎理解。什么叫做语义化呢？说的通俗点就是：明白每个标签的用途（在什么情况下使用此标签合理）比如，网页上的文章的标题就可以用标题标签，网页上的各个栏目的栏目名称也可以使用标题标签。文章中内容的段落就得放在段落标签中，在文章中有想强调的文本，就可以使用em 标签表示强调等等。语义化可以给我们带来什么样的好处呢？ 更容易被搜索引擎收录(SEO) 更容易让屏幕阅读器读出网页内容(可访问性) 代码可读性 文档声明 &lt;!DOCTYPE html&gt; 文档头部 head 标签是页面的“头部”，只能定义一些特殊的内容。一般来说，只有6 个标签能放在&lt;head&gt;标签内： &lt;head&gt;内部标签 说明 &lt;title&gt; 定义网页的标题 &lt;meta&gt; 定义网页的基本信息（供搜索引擎） &lt;style&gt; 定义CSS 样式 &lt;link&gt; 链接外部CSS 文件或脚本文件，以及favicon 样式 &lt;script&gt; 定义脚本语言 &lt;base&gt; 定义页面所有链接的基础定位 文档章节 body header nav aside article section footer h1~h6 文本 1.超链接 &lt;a&gt;&lt;/a&gt; 创建指向另一个文档的链接 创建一个文档内部的锚点 链接到Email地址 2.强调—em,strong 3.span 4.br … 组合内容 1.分区 div 2.段落 p 3.列表 无序列表 ul 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 ol 12345&lt;ol type=&apos;a&apos; start=&apos;2&apos;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 自定义列表 dl 1234567&lt;dl&gt; &lt;dt&gt;作者&lt;/dt&gt; &lt;dd&gt;Hoff&lt;/dd&gt; &lt;dd&gt;Bill&lt;/dd&gt; &lt;dt&gt;出版年&lt;/dt&gt; &lt;dd&gt;1991&lt;/dd&gt;&lt;/dl&gt; 4.pre 5.blockquote 嵌入资源 1.img 2.iframe 3.object 4.embed 5.video 6.audio 7.图形图像 canvas svg 8.热点区域 map area 表格 内容较多且重要，请自行查阅相关文档！ 表单 内容较多且重要，请自行查阅相关文档！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/younghf.github.io/tags/HTML/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/younghf.github.io/categories/前端/"}]},{"title":"Markdown","slug":"Markdown","date":"2017-11-30T06:27:20.000Z","updated":"2017-11-30T07:14:48.009Z","comments":true,"path":"2017/11/30/Markdown/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/11/30/Markdown/","excerpt":"","text":"Markdown 语法入门 第一次写博客，也是第一次用Markdown，感觉还不错吧，用的MAC，官网介绍的编辑器是MOU，结果当前的版本还不支持Sierra…所以就用了MacDown界面如下： Markdown用法很简单，语法也很少，简单练习下就可以上手，这里我就不赘述啦，直接丢链接： 简明版 Markdown 语法说明(简体中文版) 完整版 Markdown 语法说明(简体中文版) 掌握了语法就开始你的写作吧。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/younghf.github.io/categories/工具/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/younghf.github.io/tags/Markdown/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/younghf.github.io/categories/工具/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-28T08:12:14.240Z","updated":"2017-11-28T08:12:14.240Z","comments":true,"path":"2017/11/28/hello-world/","link":"","permalink":"http://yoursite.com/younghf.github.io/2017/11/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}